# -*- coding: utf-8 -*-
"""Waitlist-Manager

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16dN_WuIIQxUvwlpL4OJLrGuI9lJFLpIJ
"""

# Create a Node class to represent each customer in the waitlist
class Node:
    '''
    A class representing a node in a linked list.
    Attributes:
        name (str): The name of the customer.
        next (Node): A reference to the next node in the list.
    '''

    def __init__(self, name):
        self.name = name
        self.next = None

# Create a LinkedList class to manage the waitlist
class LinkedList:
    '''
    A class representing a linked list to manage a waitlist.
    Attributes:
        head (Node): The first node in the linked list.
    Methods:
        add_front(name): Adds a customer to the front of the waitlist.
        add_end(name): Adds a customer to the end of the waitlist.
        remove(name): Removes a customer from the waitlist by name.
        print_list(): Prints the current waitlist.
    '''
    def __init__(self):
        self.head = None

    def add_front(self, name):
        new_node = Node(name)
        new_node.next = self.head
        self.head = new_node

    def add_end(self, name):
        new_node = Node(name)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def remove(self, name):
        current = self.head
        prev = None
        while current:
            if current.name == name:
                if prev:
                    prev.next = current.next
                else:
                    self.head = current.next
                return True
            prev = current
            current = current.next
        return False

    def print_list(self):
        current = self.head
        if not current:
            print("The list is empty. Add some values!")
        else:
            while current:
                print(current.name)
                current = current.next

def waitlist_generator():
    waitlist = LinkedList()

    while True:
        print("\n--- Waitlist Manager ---")
        print("1. Add customer to front")
        print("2. Add customer to end")
        print("3. Remove customer by name")
        print("4. Print waitlist")
        print("5. Exit")

        choice = input("Choose an option (1–5): ")

        if choice == "1":
            name = input("Enter customer name to add to front: ")
            waitlist.add_front(name)

        elif choice == "2":
            name = input("Enter customer name to add to end: ")
            waitlist.add_end(name)

        elif choice == "3":
            name = input("Enter customer name to remove: ")
            if waitlist.remove(name):
                print(f"{name} removed from the waitlist.")
            else:
                print(f"{name} not found in the waitlist.")

        elif choice == "4":
            print("Current waitlist:")
            waitlist.print_list()

        elif choice == "5":
            print("Exiting waitlist manager.")
            break
        else:
            print("Invalid option. Please choose 1–5.")

# Call the waitlist_generator function to start the program

waitlist_generator()

"""
'''
Design Memo: Write Your Design Memo Include a 200–300 word response in your code or in a .txt file:
1. How does your list work?

The LinkedList stores customers as Node objects. Each Node contains the customer’s name and a reference to the next customer in the list. The list allows:

Adding a customer to the front or end of the list.

Removing a customer by name.

Printing the current list of customers.

2. What role does the head play?

The head is the first node in the linked list. It is the starting point for accessing and manipulating the list. If the list is empty, the head is None.

3. When might a real engineer need a custom list like this?

A custom linked list is useful in scenarios where frequent insertions and deletions are required.

Real-time systems where data needs to be dynamically updated.
In such cases, a linked list provides efficient insertion and deletion operations, particularly at the beginning or end of the list, compared to arrays that require shifting elements.
'''"""